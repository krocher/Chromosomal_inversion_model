// Modelling chromosomal inversions in bi-allelic populations (continent-island model)

initialize() {
	if (!exists("Rep")) defineConstant("Rep",1);  // Identifier of the simulation amongst simulations with identical parameters
	defineConstant("FileName","Test_fitness");  // Suffix for the name of the generated files
	defineConstant("Mu",1e-6);  // Mutation rate
	defineConstant("R",1e-8);   // Recombination rate
	defineConstant("L",2e2);   // Sequence length
	defineConstant("T_INV", 40000);  // Burn-in time before introducing inversions
	defineConstant("I",0.1);  // Initial proportion of inverted arrangements in population 2
	defineConstant("INV_LENGTH",100);   // Inversion length
	defineConstant("INV_START", asInteger(L/2 - INV_LENGTH/2));  // Beginning position of the inversion
	defineConstant("INV_END", INV_START + INV_LENGTH - 1);  // End position of the inversion
	defineConstant("N",2000);  // Population size
	defineConstant("H",0.0);  // Dominance of the mutations
	defineConstant("H_INV",0.5);  // Dominance of the inversion
	defineConstant("S", -0.01); // Selection coefficient for the mutations
	defineConstant("S_INV", 0.02); // Selection coefficient for the inversion
	defineConstant("m",0.01);   // Migration rate
	defineConstant("T_MAX", 200000); // Time of simulation end
	defineConstant("LOG_INTERVAL", 100); // Time interval for logging inversion frequencies and number of deleterious mutations
	defineConstant("Double_Crossover",F); // Inclusion or not of double crossovers
	
	initializeMutationRate(Mu);
	
	initializeMutationType("m1", H, "f", S);   // Defining deleterious mutations
	m1.convertToSubstitution = F;    // Allowing loci to have back-mutations after one allele is fixed
	m1.color = "red";
	
	initializeMutationType("m2",H,"f",S);   // Mutations that will be created in the haplosome
	m2.convertToSubstitution = F;      // Same as earlier
	m2.color = "cornflowerblue";
	
	initializeMutationType("m3",H_INV,"f",S_INV);   // Start marker
	initializeMutationType("m4",H_INV,"f",S_INV);   // End marker
	c(m3,m4).convertToSubstitution = T;    // Inversion can get fixed, replace by F if we wanted double/back-inversions
	c(m3,m4).color = "yellow";
	
	
	initializeGenomicElementType("g1", m2, 1.0);    // Defining the genomic element on which deleterious mutations will appear
	
	// uniform chromosome with uniform recombination
	initializeGenomicElement(g1, 0,L-1);
	
	initializeRecombinationRate(R);

}

1 early() {
	sim.addSubpop("p1", N);
	sim.addSubpop("p2", N);  // Creating 2 subpopulations of same size
	p2.setMigrationRates(p1,m);    // Setting the migration rate from the continent to the island
	
	target = p1.haplosomes[0];
	target.addNewDrawnMutation(m1, 0:(L-1));
	defineConstant("MUT", target.mutations);   // Creating the structure that will be used in all haplosomes
	
	target.removeMutations();   // Removing , all haplosomes will be "aa" by default
	
	// log results for inversion frequencies
	log = community.createLogFile(paste("/home/taubier/Documents/SAUVEGARDES_STAGIAIRES/Kilian/Results/Result_files/freq_",FileName,"Rep",Rep,".csv"), logInterval = LOG_INTERVAL);
	log.addTick();
	log.addCustomColumn("inv_freq","p2Individuals = sim.subpopulations[1].individuals; sum(p2Individuals.countOfMutationsOfType(m3))/(p2.haplosomes.size());");  // Frequency of the inverted arrangement amongst haplosomes
	log.addCustomColumn("n_non_inv_haplosomes", "haplosomes = p2.haplosomes; counts = haplosomes.countOfMutationsOfType(m3); non_inv = haplosomes[counts == 0]; non_inv.size();");
	log.addCustomColumn("n_mut_per_non_inv_haplosome","haplosomes = p2.haplosomes; counts = haplosomes.countOfMutationsOfType(m3); non_inv = haplosomes[counts == 0]; pos = non_inv.positionsOfMutationsOfType(m1); sum((pos >= INV_START) & (pos <= INV_END))/(non_inv.size());");
	log.addCustomColumn("n_inv_haplosomes", "haplosomes = p2.haplosomes; counts = haplosomes.countOfMutationsOfType(m3); inv = haplosomes[counts > 0]; inv.size();");
	log.addCustomColumn("n_mut_per_inv_haplosome","haplosomes = p2.haplosomes; counts = haplosomes.countOfMutationsOfType(m3); inv = haplosomes[counts > 0]; pos = inv.positionsOfMutationsOfType(m1); sum((pos >= INV_START) & (pos <= INV_END))/(inv.size());");
	log.addCustomColumn("inv_fitness","p2Individuals = sim.subpopulations[1].individuals; inv_freq = sum(p2Individuals.countOfMutationsOfType(m3))/(p2.haplosomes.size()); (1+S_INV)*inv_freq + (1+H_INV*S_INV)*(1-inv_freq);");
    log.addCustomColumn("non_inv_fitness","p2Individuals = sim.subpopulations[1].individuals; inv_freq = sum(p2Individuals.countOfMutationsOfType(m3))/(p2.haplosomes.size()); (1+S_INV)*(1-inv_freq)+1*inv_freq;");
	
	// proportion of simulations with inverted haplosomes still existing (in Bash)
}

T_INV late() {
	inverted = sample(p2.haplosomes,asInteger(I*N));    // Inverting some of the haplosomes
	inverted.addNewDrawnMutation(m3, INV_START);
	inverted.addNewDrawnMutation(m4, INV_END);
}

T_INV:T_MAX late() {
	if (sim.countOfMutationsOfType(m3)==0) {
		writeFile("/home/taubier/Documents/SAUVEGARDES_STAGIAIRES/Kilian/Results/Result_files/last_generation.txt",paste("Time of loss of the inversion","(Rep ",Rep,"): ", sim.cycle));   // Exporting into a file the time of loss of the inversion, 
		sim.simulationFinished();
	}
}

recombination() {
	gm1 = haplosome1.containsMarkerMutation(m3, INV_START);
	gm2 = haplosome2.containsMarkerMutation(m3, INV_START);
	if (!(gm1 | gm2)) {
		// homozygote non-inverted: recombination is not affected
		return F;
	}
	inInv = (breakpoints > INV_START) & (breakpoints <= INV_END);
	if (Double_Crossover) {
		if (sum(inInv) % 2 == 0) {
			return F;  // if there is an even number of recombinations in the inversion; it leads to viable gametes, therefore recombination may not be suppressed
		}
		if (gm1 & gm2) {
		// homozygote inverted: 2 breakpoints are added at the beginning and the end of the inversion to get the correct base at both ends of the inversion
			left = (breakpoints == INV_START);
			right = (breakpoints == INV_END + 1);
			breakpoints = sort(c(breakpoints[!(left | right)],
				c(INV_START, INV_END + 1)[c(sum(left) == 0, sum(right) == 0)]));   // sort them in the right order depending on the haplosome arrangement
			return T;
		} else {
			// heterozygote inverted: resample to get an even # of breakpoints
			// this is *recursive*: it calls this recombination callback again!
			breakpoints = sim.chromosomes.drawBreakpoints(individual);
		}
		return T;
	} else {
		if (!any(inInv)) {
			return F;
		}
		if (sum(inInv) % 2 == 0) {
			if (gm1 != gm2) {
				breakpoints = breakpoints[!inInv];
				return T; 
			} else {
				return F;
			}
		}  
		if (gm1 & gm2) {
			// homozygote inverted: 2 breakpoints are added at the beginning and the end of the inversion to get the correct base at both ends of the inversion
			left = (breakpoints == INV_START);
			right = (breakpoints == INV_END + 1);
			breakpoints = sort(c(breakpoints[!(left | right)],
				c(INV_START, INV_END + 1)[c(sum(left) == 0, sum(right) == 0)]));   // sort them in the right order depending on the haplosome arrangement
			return T;
		} else {
			breakpoints = breakpoints[!inInv];
			return T;  
		}	
	}	
}




// Replacing the SLiM default mutation function by one that returns the opposite allele from the one previously present
mutation(m2) {
	if (haplosome.containsMarkerMutation(m1,mut.position))
		return T;
	return MUT[mut.position];
}

late() {
	m2muts = sim.mutationsOfType(m2);   // Implementing back-mutations from A to a
	
	// do we have any m2 mutations segregating?
	// if so, we have m1/m2 stacked mutations to remove
	if (m2muts.length() > 0)
	{
		haplosomes = sim.subpopulations.haplosomes;
		counts = haplosomes.countOfMutationsOfType(m2);
		hasStacked = haplosomes[counts > 0];
		
		for (haplosome in hasStacked)
		{
			stacked_m2 = haplosome.mutationsOfType(m2);
			stackPositions = stacked_m2.position;
			all_m1 = haplosome.mutationsOfType(m1);
			s = (match(all_m1.position, stackPositions) >= 0);
			stacked_m1 = all_m1[s];
			haplosome.removeMutations(c(stacked_m2, stacked_m1));
		}
	}
}

// Simulation stop
T_MAX late() { }